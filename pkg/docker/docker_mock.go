// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package docker

import (
	"context"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"sync"
)

var (
	lockDockerMockContainerConfig       sync.RWMutex
	lockDockerMockContainerCreate       sync.RWMutex
	lockDockerMockContainerExecAttach   sync.RWMutex
	lockDockerMockContainerExecCreate   sync.RWMutex
	lockDockerMockContainerStart        sync.RWMutex
	lockDockerMockGenerateContainerName sync.RWMutex
	lockDockerMockNetworkConnect        sync.RWMutex
	lockDockerMockNetworkingConfig      sync.RWMutex
)

// Ensure, that DockerMock does implement Docker.
// If this is not the case, regenerate this file with moq.
var _ Docker = &DockerMock{}

// DockerMock is a mock implementation of Docker.
//
//     func TestSomethingThatUsesDocker(t *testing.T) {
//
//         // make and configure a mocked Docker
//         mockedDocker := &DockerMock{
//             ContainerConfigFunc: func(image string, virtualhost string) *container.Config {
// 	               panic("mock out the ContainerConfig method")
//             },
//             ContainerCreateFunc: func(ctx context.Context, opts *CreateOpts) (string, error) {
// 	               panic("mock out the ContainerCreate method")
//             },
//             ContainerExecAttachFunc: func(ctx context.Context, execID string, config types.ExecConfig) (types.HijackedResponse, error) {
// 	               panic("mock out the ContainerExecAttach method")
//             },
//             ContainerExecCreateFunc: func(ctx context.Context, container string, config types.ExecConfig) (types.IDResponse, error) {
// 	               panic("mock out the ContainerExecCreate method")
//             },
//             ContainerStartFunc: func(ctx context.Context, containerID string, options types.ContainerStartOptions) error {
// 	               panic("mock out the ContainerStart method")
//             },
//             GenerateContainerNameFunc: func() string {
// 	               panic("mock out the GenerateContainerName method")
//             },
//             NetworkConnectFunc: func(ctx context.Context, preffix string, name string) (*network.NetworkingConfig, error) {
// 	               panic("mock out the NetworkConnect method")
//             },
//             NetworkingConfigFunc: func(networkID string) *network.NetworkingConfig {
// 	               panic("mock out the NetworkingConfig method")
//             },
//         }
//
//         // use mockedDocker in code that requires Docker
//         // and then make assertions.
//
//     }
type DockerMock struct {
	// ContainerConfigFunc mocks the ContainerConfig method.
	ContainerConfigFunc func(image string, virtualhost string) *container.Config

	// ContainerCreateFunc mocks the ContainerCreate method.
	ContainerCreateFunc func(ctx context.Context, opts *CreateOpts) (string, error)

	// ContainerExecAttachFunc mocks the ContainerExecAttach method.
	ContainerExecAttachFunc func(ctx context.Context, execID string, config types.ExecConfig) (types.HijackedResponse, error)

	// ContainerExecCreateFunc mocks the ContainerExecCreate method.
	ContainerExecCreateFunc func(ctx context.Context, container string, config types.ExecConfig) (types.IDResponse, error)

	// ContainerStartFunc mocks the ContainerStart method.
	ContainerStartFunc func(ctx context.Context, containerID string, options types.ContainerStartOptions) error

	// GenerateContainerNameFunc mocks the GenerateContainerName method.
	GenerateContainerNameFunc func() string

	// NetworkConnectFunc mocks the NetworkConnect method.
	NetworkConnectFunc func(ctx context.Context, preffix string, name string) (*network.NetworkingConfig, error)

	// NetworkingConfigFunc mocks the NetworkingConfig method.
	NetworkingConfigFunc func(networkID string) *network.NetworkingConfig

	// calls tracks calls to the methods.
	calls struct {
		// ContainerConfig holds details about calls to the ContainerConfig method.
		ContainerConfig []struct {
			// Image is the image argument value.
			Image string
			// Virtualhost is the virtualhost argument value.
			Virtualhost string
		}
		// ContainerCreate holds details about calls to the ContainerCreate method.
		ContainerCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts *CreateOpts
		}
		// ContainerExecAttach holds details about calls to the ContainerExecAttach method.
		ContainerExecAttach []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ExecID is the execID argument value.
			ExecID string
			// Config is the config argument value.
			Config types.ExecConfig
		}
		// ContainerExecCreate holds details about calls to the ContainerExecCreate method.
		ContainerExecCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Container is the container argument value.
			Container string
			// Config is the config argument value.
			Config types.ExecConfig
		}
		// ContainerStart holds details about calls to the ContainerStart method.
		ContainerStart []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ContainerID is the containerID argument value.
			ContainerID string
			// Options is the options argument value.
			Options types.ContainerStartOptions
		}
		// GenerateContainerName holds details about calls to the GenerateContainerName method.
		GenerateContainerName []struct {
		}
		// NetworkConnect holds details about calls to the NetworkConnect method.
		NetworkConnect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Preffix is the preffix argument value.
			Preffix string
			// Name is the name argument value.
			Name string
		}
		// NetworkingConfig holds details about calls to the NetworkingConfig method.
		NetworkingConfig []struct {
			// NetworkID is the networkID argument value.
			NetworkID string
		}
	}
}

// ContainerConfig calls ContainerConfigFunc.
func (mock *DockerMock) ContainerConfig(image string, virtualhost string) *container.Config {
	if mock.ContainerConfigFunc == nil {
		panic("DockerMock.ContainerConfigFunc: method is nil but Docker.ContainerConfig was just called")
	}
	callInfo := struct {
		Image       string
		Virtualhost string
	}{
		Image:       image,
		Virtualhost: virtualhost,
	}
	lockDockerMockContainerConfig.Lock()
	mock.calls.ContainerConfig = append(mock.calls.ContainerConfig, callInfo)
	lockDockerMockContainerConfig.Unlock()
	return mock.ContainerConfigFunc(image, virtualhost)
}

// ContainerConfigCalls gets all the calls that were made to ContainerConfig.
// Check the length with:
//     len(mockedDocker.ContainerConfigCalls())
func (mock *DockerMock) ContainerConfigCalls() []struct {
	Image       string
	Virtualhost string
} {
	var calls []struct {
		Image       string
		Virtualhost string
	}
	lockDockerMockContainerConfig.RLock()
	calls = mock.calls.ContainerConfig
	lockDockerMockContainerConfig.RUnlock()
	return calls
}

// ContainerCreate calls ContainerCreateFunc.
func (mock *DockerMock) ContainerCreate(ctx context.Context, opts *CreateOpts) (string, error) {
	if mock.ContainerCreateFunc == nil {
		panic("DockerMock.ContainerCreateFunc: method is nil but Docker.ContainerCreate was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts *CreateOpts
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	lockDockerMockContainerCreate.Lock()
	mock.calls.ContainerCreate = append(mock.calls.ContainerCreate, callInfo)
	lockDockerMockContainerCreate.Unlock()
	return mock.ContainerCreateFunc(ctx, opts)
}

// ContainerCreateCalls gets all the calls that were made to ContainerCreate.
// Check the length with:
//     len(mockedDocker.ContainerCreateCalls())
func (mock *DockerMock) ContainerCreateCalls() []struct {
	Ctx  context.Context
	Opts *CreateOpts
} {
	var calls []struct {
		Ctx  context.Context
		Opts *CreateOpts
	}
	lockDockerMockContainerCreate.RLock()
	calls = mock.calls.ContainerCreate
	lockDockerMockContainerCreate.RUnlock()
	return calls
}

// ContainerExecAttach calls ContainerExecAttachFunc.
func (mock *DockerMock) ContainerExecAttach(ctx context.Context, execID string, config types.ExecConfig) (types.HijackedResponse, error) {
	if mock.ContainerExecAttachFunc == nil {
		panic("DockerMock.ContainerExecAttachFunc: method is nil but Docker.ContainerExecAttach was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ExecID string
		Config types.ExecConfig
	}{
		Ctx:    ctx,
		ExecID: execID,
		Config: config,
	}
	lockDockerMockContainerExecAttach.Lock()
	mock.calls.ContainerExecAttach = append(mock.calls.ContainerExecAttach, callInfo)
	lockDockerMockContainerExecAttach.Unlock()
	return mock.ContainerExecAttachFunc(ctx, execID, config)
}

// ContainerExecAttachCalls gets all the calls that were made to ContainerExecAttach.
// Check the length with:
//     len(mockedDocker.ContainerExecAttachCalls())
func (mock *DockerMock) ContainerExecAttachCalls() []struct {
	Ctx    context.Context
	ExecID string
	Config types.ExecConfig
} {
	var calls []struct {
		Ctx    context.Context
		ExecID string
		Config types.ExecConfig
	}
	lockDockerMockContainerExecAttach.RLock()
	calls = mock.calls.ContainerExecAttach
	lockDockerMockContainerExecAttach.RUnlock()
	return calls
}

// ContainerExecCreate calls ContainerExecCreateFunc.
func (mock *DockerMock) ContainerExecCreate(ctx context.Context, container string, config types.ExecConfig) (types.IDResponse, error) {
	if mock.ContainerExecCreateFunc == nil {
		panic("DockerMock.ContainerExecCreateFunc: method is nil but Docker.ContainerExecCreate was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Container string
		Config    types.ExecConfig
	}{
		Ctx:       ctx,
		Container: container,
		Config:    config,
	}
	lockDockerMockContainerExecCreate.Lock()
	mock.calls.ContainerExecCreate = append(mock.calls.ContainerExecCreate, callInfo)
	lockDockerMockContainerExecCreate.Unlock()
	return mock.ContainerExecCreateFunc(ctx, container, config)
}

// ContainerExecCreateCalls gets all the calls that were made to ContainerExecCreate.
// Check the length with:
//     len(mockedDocker.ContainerExecCreateCalls())
func (mock *DockerMock) ContainerExecCreateCalls() []struct {
	Ctx       context.Context
	Container string
	Config    types.ExecConfig
} {
	var calls []struct {
		Ctx       context.Context
		Container string
		Config    types.ExecConfig
	}
	lockDockerMockContainerExecCreate.RLock()
	calls = mock.calls.ContainerExecCreate
	lockDockerMockContainerExecCreate.RUnlock()
	return calls
}

// ContainerStart calls ContainerStartFunc.
func (mock *DockerMock) ContainerStart(ctx context.Context, containerID string, options types.ContainerStartOptions) error {
	if mock.ContainerStartFunc == nil {
		panic("DockerMock.ContainerStartFunc: method is nil but Docker.ContainerStart was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ContainerID string
		Options     types.ContainerStartOptions
	}{
		Ctx:         ctx,
		ContainerID: containerID,
		Options:     options,
	}
	lockDockerMockContainerStart.Lock()
	mock.calls.ContainerStart = append(mock.calls.ContainerStart, callInfo)
	lockDockerMockContainerStart.Unlock()
	return mock.ContainerStartFunc(ctx, containerID, options)
}

// ContainerStartCalls gets all the calls that were made to ContainerStart.
// Check the length with:
//     len(mockedDocker.ContainerStartCalls())
func (mock *DockerMock) ContainerStartCalls() []struct {
	Ctx         context.Context
	ContainerID string
	Options     types.ContainerStartOptions
} {
	var calls []struct {
		Ctx         context.Context
		ContainerID string
		Options     types.ContainerStartOptions
	}
	lockDockerMockContainerStart.RLock()
	calls = mock.calls.ContainerStart
	lockDockerMockContainerStart.RUnlock()
	return calls
}

// GenerateContainerName calls GenerateContainerNameFunc.
func (mock *DockerMock) GenerateContainerName() string {
	if mock.GenerateContainerNameFunc == nil {
		panic("DockerMock.GenerateContainerNameFunc: method is nil but Docker.GenerateContainerName was just called")
	}
	callInfo := struct {
	}{}
	lockDockerMockGenerateContainerName.Lock()
	mock.calls.GenerateContainerName = append(mock.calls.GenerateContainerName, callInfo)
	lockDockerMockGenerateContainerName.Unlock()
	return mock.GenerateContainerNameFunc()
}

// GenerateContainerNameCalls gets all the calls that were made to GenerateContainerName.
// Check the length with:
//     len(mockedDocker.GenerateContainerNameCalls())
func (mock *DockerMock) GenerateContainerNameCalls() []struct {
} {
	var calls []struct {
	}
	lockDockerMockGenerateContainerName.RLock()
	calls = mock.calls.GenerateContainerName
	lockDockerMockGenerateContainerName.RUnlock()
	return calls
}

// NetworkConnect calls NetworkConnectFunc.
func (mock *DockerMock) NetworkConnect(ctx context.Context, preffix string, name string) (*network.NetworkingConfig, error) {
	if mock.NetworkConnectFunc == nil {
		panic("DockerMock.NetworkConnectFunc: method is nil but Docker.NetworkConnect was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Preffix string
		Name    string
	}{
		Ctx:     ctx,
		Preffix: preffix,
		Name:    name,
	}
	lockDockerMockNetworkConnect.Lock()
	mock.calls.NetworkConnect = append(mock.calls.NetworkConnect, callInfo)
	lockDockerMockNetworkConnect.Unlock()
	return mock.NetworkConnectFunc(ctx, preffix, name)
}

// NetworkConnectCalls gets all the calls that were made to NetworkConnect.
// Check the length with:
//     len(mockedDocker.NetworkConnectCalls())
func (mock *DockerMock) NetworkConnectCalls() []struct {
	Ctx     context.Context
	Preffix string
	Name    string
} {
	var calls []struct {
		Ctx     context.Context
		Preffix string
		Name    string
	}
	lockDockerMockNetworkConnect.RLock()
	calls = mock.calls.NetworkConnect
	lockDockerMockNetworkConnect.RUnlock()
	return calls
}

// NetworkingConfig calls NetworkingConfigFunc.
func (mock *DockerMock) NetworkingConfig(networkID string) *network.NetworkingConfig {
	if mock.NetworkingConfigFunc == nil {
		panic("DockerMock.NetworkingConfigFunc: method is nil but Docker.NetworkingConfig was just called")
	}
	callInfo := struct {
		NetworkID string
	}{
		NetworkID: networkID,
	}
	lockDockerMockNetworkingConfig.Lock()
	mock.calls.NetworkingConfig = append(mock.calls.NetworkingConfig, callInfo)
	lockDockerMockNetworkingConfig.Unlock()
	return mock.NetworkingConfigFunc(networkID)
}

// NetworkingConfigCalls gets all the calls that were made to NetworkingConfig.
// Check the length with:
//     len(mockedDocker.NetworkingConfigCalls())
func (mock *DockerMock) NetworkingConfigCalls() []struct {
	NetworkID string
} {
	var calls []struct {
		NetworkID string
	}
	lockDockerMockNetworkingConfig.RLock()
	calls = mock.calls.NetworkingConfig
	lockDockerMockNetworkingConfig.RUnlock()
	return calls
}
